
资源绑定概述
======

_发布日期：2022年10月26日_

理解 DirectX 12 中资源绑定的关键在于以下几个概念：**描述符（Descriptor）**、**描述符表（Descriptor Table）**、**描述符堆（Descriptor Heap）** 和 **根签名（Root Signature）**。

* * *

一、资源与图形管线
---------

着色器资源（例如纹理、常量缓冲区、图像、缓冲区等）**不会直接绑定到着色器管线**，而是通过**描述符（Descriptor）**进行引用。描述符是一个小型对象，包含关于单个资源的信息。

多个描述符可以组合成**描述符表（Descriptor Table）**，每个描述符表通常存储某一类资源的描述符。一些常见资源类型如下：

* 常量缓冲区视图（CBV）
    
* 无序访问视图（UAV）
    
* 着色器资源视图（SRV）
    
* 采样器（Sampler）
    

其中，**SRV、UAV 和 CBV 可以合并在同一个描述符表中**。

图形管线与计算管线通过索引访问描述符表中的资源。

* * *

二、描述符堆（Descriptor Heap）
-----------------------

描述符表存储在**描述符堆**中。理想情况下，一个描述符堆应该包含一帧甚至多帧渲染所需的所有描述符。所有资源都存储在用户模式下的堆中。

* * *

三、根签名（Root Signature）
---------------------

**根签名**是由应用程序定义的绑定约定，用于告知着色器如何访问资源。根签名可以包含以下内容：

* 指向描述符堆中描述符表的索引（描述符表的布局需预先定义）；
    
* **常量值（Root Constants）**：允许应用直接将常量绑定到着色器，无需通过描述符或描述符表；
    
* 直接放入根签名中的少量描述符，如每次绘制变化的 CBV，可节省将其放入堆中的开销。
    

> 也就是说，根签名提供了对**小量且高频变化数据的性能优化**。

* * *

四、Direct3D 12 中的资源绑定设计
----------------------

Direct3D 12 将资源绑定与以下任务解耦：

* 内存管理
    
* 对象生命周期管理
    
* 状态跟踪
    
* 内存同步
    

相比 D3D11，D3D12 的绑定机制**开销更低、适用于频繁调用、具有更强的可扩展性**（从低端到高端硬件，从线性到并行的图形引擎设计）。

* * *

五、资源类型与视图（Resource Types & Views）
---------------------------------

资源类型与 D3D11 相同：

* `Texture1D`, `Texture1DArray`
    
* `Texture2D`, `Texture2DArray`, `Texture2DMS`, `Texture2DMSArray`
    
* `Texture3D`
    
* 各类缓冲区（类型化、结构化、原始）
    

资源视图类型也类似，但做了一些扩展，新增了顶点和索引缓冲区视图：

* 常量缓冲区视图（CBV）
    
* 无序访问视图（UAV）
    
* 着色器资源视图（SRV）
    
* 采样器（Sampler）
    
* 渲染目标视图（RTV）
    
* 深度模板视图（DSV）
    
* 索引缓冲区视图（IBV）
    
* 顶点缓冲区视图（VBV）
    
* 流输出视图（SOV）
    

> 其中，仅 **CBV、UAV、SRV、Sampler** 是对着色器可见的，请参考：[Shader 可见与不可见的描述符堆](https://learn.microsoft.com)。

* * *

六、资源绑定控制流程
----------

以下是仅关注根签名、描述符表/堆、根描述符与根常量的渲染逻辑流程：

1. **创建一个或多个根签名对象**，每种绑定配置一个；
    
2. **使用对应的根签名创建着色器和管线状态对象**；
    
3. **创建描述符堆**（可多个），包含每帧渲染所需的 SRV、UAV 和 CBV；
    
4. 初始化描述符堆，填充那些会跨帧复用的描述符；
    
5. 对于每帧：
    
    * 对于每个命令列表：
        
        * 设置当前根签名（必要时可更换）；
            
        * 更新根签名中的常量或描述符（如世界/视图矩阵）；
            
        * 对于每个要绘制的物体：
            
            * 若有需要，为该物体创建新的描述符；
                
            * 更新根签名中指向描述符堆的指针（描述符表）；
                
            * 更新每物体的常量/描述符；
                
            * 设置与当前根签名兼容的管线状态（如有需要）；
                
            * 调用 Draw；
                
        * 继续绘制下一个物体；
            
    * 继续下一个命令列表；
        
6. **当 GPU 使用完某内存区域后，可以释放资源**；
    
    * 如果描述符不再用于后续渲染，可直接复用描述符堆空间；
        
7. 继续下一帧渲染；
    

* * *

七、非着色器可见的描述符类型
--------------

以下描述符（RTV、DSV、IBV、VBV、SOV）由驱动管理版本：

* 渲染目标视图（RTV）
    
* 深度模板视图（DSV）
    
* 顶点缓冲区视图（VBV）
    
* 索引缓冲区视图（IBV）
    
* 流输出视图（SOV）
    

与 Shader-visible 的描述符堆不同，应用程序**必须手动管理 Shader-visible 堆的内容版本**（手动分配空间、避免覆盖等）。这也是为了支持：

* 重用不变描述符；
    
* 使用静态大堆并用 shader 索引（如材质 ID）访问；
    
* 不同策略结合使用。
    

硬件无法自动处理这种灵活性，所以这部分必须由开发者控制。

* * *

八、子分配（Suballocation）
--------------------

D3D12 给予开发者**底层内存控制权**。不像 D3D11 每资源一个内存块，D3D12 允许：

1. 一次性申请一大块内存；
    
2. 创建多个描述符指向这块内存中的不同部分。
    

这种“子分配”策略有助于提高内存与计算效率，取代 D3D11 中的资源重命名机制。通过 **栅栏（Fence）**，应用可以判断某资源是否仍被 GPU 使用。

* * *

九、释放资源
------

任何绑定到管线的资源在释放之前，**GPU 必须先完成对其的使用**。

### 同步方式：

* **等待一帧渲染完成**（粗粒度）；
    
* **使用栅栏（Fence）同步**（细粒度）：
    
    * 在命令列表中插入栅栏；
        
    * 使用该栅栏等待 GPU 执行完成；
        
    * 或使用事件通知 CPU 线程。
        

在 D3D11 中这类似于 `EnqueueSetEvent()`。

* * *