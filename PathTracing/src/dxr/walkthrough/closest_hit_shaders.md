# Closest Hit Shader（最近命中着色器）

> 当一个光线射出后，与场景中的某些物体相交，其中**距离最近的那次合法相交**，可以由一个专门的着色器来处理，这个着色器就叫做**最近命中着色器（Closest Hit Shader）**。

这个着色器可以：

* 读取相交点的一些属性（比如位置、法线等），
    
* 修改光线携带的数据（payload），
    
* 或者生成新的光线继续追踪。
    

常见的用途就是根据表面属性算出颜色，然后把结果存储到光线的 payload 中，或者写入内存（通过 UAV）。

> 注意：在执行最近命中着色器之前，如果光线沿途配置了 Any Hit Shader（任意命中着色器），这些 Any Hit Shader 会先被执行。如果同一个物体上同时设置了 Any Hit 和 Closest Hit，那么总是 **先执行 Any Hit，再执行 Closest Hit**。

* * *

# Miss Shader（未命中着色器）

如果光线最终没有与任何物体相交，就会执行一个叫做**未命中着色器（Miss Shader）**的东西。

这个着色器也可以：

* 修改光线的 payload，
    
* 生成新的光线。
    

因为没有发生相交，所以 Miss Shader 中拿不到任何交点属性。

* * *

# Hit Group（命中组）

一个**命中组（Hit Group）**是几个着色器的组合，包含：

* 0或1个 相交着色器（Intersection Shader），
    
* 0或1个 任意命中着色器（Any Hit Shader），
    
* 0或1个 最近命中着色器（Closest Hit Shader）。
    

场景中每个具体的几何体都会引用某个命中组，用这个组来提供它的着色器逻辑。

这么分组的目的是：方便 GPU 编译和执行，提升性能。

* 如果命中组中包含 **相交着色器**，那么这个组只能用在“程序化几何体”（Procedural Geometry，比如体积、曲线等）上。
    
* 如果没有相交着色器，那它只能用在 **三角形几何体** 上。
    

此外，也可以有一个什么都没有的空命中组（着色器标识符为 NULL）。这种情况下，会被认为是“完全不透明的几何体”，光线射到这里就不再继续下去。

有时程序不想对光线命中做任何处理，只关注未命中的情况，那么用一个空的命中组就是很实用的方式。

* * *

在光线追踪中，**每次光线和场景中的几何体相交时，都会触发一系列的着色器来决定怎么处理这个“命中”**。

通常来说：

* 会有一个“最近命中着色器”来处理这个交点，比如决定颜色、阴影、反射等。
    
* 有时还会有“任意命中着色器”来自定义更复杂的交点行为，比如透明度检测、Alpha Test 等。
    

* * *

### 什么是“空命中组”？

如果你**没有为某个几何体提供任何着色器**（即没有交点着色器、任意命中着色器、最近命中着色器），这个“命中组”就是空的，表现为一个 `NULL` 着色器标识符。

**这个空的命中组就像一种默认行为：**

* 如果光线打到了这个物体，它就会立即认为“这个物体完全挡住了光线”。
    
* 不会执行任何逻辑（因为没有着色器可执行），
    
* 光线也不会继续穿透、折射、反弹——就像撞到了一个“黑洞”或“不透明的墙”。
    

* * *

### “完全不透明”是什么意思？

指的是：

* **光线打到这里就停了**，不会继续传播。
    
* 就像传统渲染中的“Z-buffer遮挡”：挡住了后面的东西，也没颜色也没特效，就是被吃掉了。
    
* 在视觉效果上，默认它不会有颜色贡献（除非你手动修改 payload）。
    

* * *

### 为什么这种“空命中组”会有用？

假设你有一个需求：

* **你只对“光线没有打中任何物体”的情况感兴趣**，比如你想检测“某条方向上是不是空的”。
    
* 这时如果光线碰到一个物体，你不想浪费资源去处理它，也不关心它的颜色、阴影等等。
    

那么：

* 给这些物体绑定一个空的命中组，
    
* 这样一旦光线打中它，系统就会自动终止这条光线的追踪，
    
* 而你只会在 Miss Shader 中处理那些真正“什么都没打中的”光线。
    

这种技巧 **可以简化逻辑、提高性能**，尤其是在只想分析“是否命中”而不是“命中了什么”的场景中非常有用。

* * *

### 总结

空命中组就像是一个：

> “光线打中我就算结束，不要再处理，也不要问我是谁，我什么都不会说。”

你可以把它当作一种“无声的、不透明的黑色面板”挂在场景里，用来控制光线行为而不是生成可见图像。

* * *

### 一、空命中组 = 没有任何命中着色器

当你把几何体绑定一个空命中组时（也就是不提供 `ClosestHit` / `AnyHit` / `Intersection` 着色器）：

* 光线**确实命中了几何体**，
    
* 但由于没有命中着色器可执行，**不会对光线 payload 做任何修改**，
    
* 如果你在 RayGen shader 中依赖 payload 的值来决定颜色，那这个光线就像“什么都没发生”一样返回来。
    

所以：

* 如果你没有设置 payload 的默认值，也没在 Miss Shader 中处理它，
    
* **那么这个光线对应的像素最终颜色就是黑的**（因为 payload 是默认初始化的，比如 float3(0,0,0)）。
    

* * *

### 二、是否“黑色”取决于你的 payload 和 raygen 逻辑

举个例子：

```hlsl
// payload
struct MyPayload {
    float3 color;
};

// raygen shader 中
[shader("raygeneration")]
void RayGenMain()
{
    MyPayload payload = {};
    RayDesc ray = ...;

    TraceRay(..., payload);

    // 根据 payload 的结果写入渲染目标
    RenderTarget[DispatchRaysIndex().xy] = float4(payload.color, 1.0);
}
```

在这个例子里：

* 如果空命中组导致没有人去写 `payload.color`，
    
* 那默认就是 (0,0,0)，也就是黑色。
    

* * *

### 三、空命中组 ≠ 黑色材质

非常重要的区别：

> **空命中组只是“没有处理”这个命中，并不意味着你“主动赋了黑色”或者用了“黑色材质”。**

你完全可以：

* 在 raygen shader 中设定默认颜色，
    
* 在 miss shader 中改颜色，
    
* 或者在某些情况下使用其它数据源赋值。
    

* * *

### 四、实际用途回顾

空命中组常用于：

* 只需要“阻挡光线”的物体（如加速结构中的不可见遮挡物、阴影体积等）；
    
* 做 visibility 测试（例如判断一条射线是否被挡）；
    
* 加速不关心命中细节的场景（比如 AO、光照探针检测）；
    

它不是用来“渲染颜色”的，所以默认它不会贡献颜色，表现为黑色是个**副产品**，不是本意。

* * *

### ✅ 总结一句话：

> 空命中组不会生成颜色贡献，如果你不主动修改 payload，它对应的像素就是黑色。但你完全可以在其他 shader 中控制这个行为。
