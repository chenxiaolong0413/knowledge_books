# 可调用着色器（Callable Shaders）

------------------------

可调用着色器的设计目的是：**在面对复杂、分支较多的着色器组合（shader permutations）或着色器网络（shader networks）时，提供一种更灵活的组织方式**。不过，它可能会带来一些执行效率上的损耗。

* * *

### 一、什么是可调用着色器？

它们是通过一个“**着色器表（shader table）**”定义的，本质上是一个用户自定义的“函数表”。这个表通过 GPU 虚拟地址提供给 `DispatchRays()` 函数，地址填写在结构体 `D3D12_DISPATCH_RAYS_DESC` 的 `CallableShaderTable` 字段中。

表的内容是由状态对象（State Object）中通过 `GetShaderIdentifier()` 获取的“**着色器标识符**”组成的。

* * *

### 二、怎么调用可调用着色器？

在任意一个光线追踪着色器中（如 Ray Generation、Closest Hit 等），都可以使用 `CallShader()` HLSL 函数来调用某个可调用着色器。这个调用通过索引 shader 表来确定调用哪个函数。

调用行为就像是一个普通的子函数调用（Subroutine Call），允许传入任意参数，并在执行完毕后返回到原位置继续执行。

⚠️ 注意：

* 可调用着色器是**独立编译的**，编译器无法对调用方和被调用方之间进行任何优化（比如内联）。
    
* 系统会使用一块用户可定义大小的“栈空间”（stack）来传递参数或保存中间状态，这些参数有些可能没法通过寄存器传递。
    

* * *

### 三、执行原理与效率

可调用着色器是由 GPU 独立调度执行的，**并不会像传统函数那样被内联优化到调用者中**。这一点类似于 `TraceRay()` 调用后触发的其他着色器运行。

因此，**如果你只是想执行一个很小的逻辑功能，调用可调用着色器可能得不偿失**，因为调度这个“函数”本身就有开销。

* * *

### 四、替代方案与优劣

没有可调用着色器这个功能时，有些应用可能会通过“Trace 一个 Guaranteed Miss 的光线”来达成类似功能：

* 这种做法是：构造一个一定不会命中任何几何体的光线；
    
* 然后触发 Miss Shader，把 Ray Payload 当作函数参数用；
    
* 但这种做法显然浪费资源，光线注定失败，却还要构造和处理。
    

相比之下，**可调用着色器是一种更清晰、效率更高的替代方案**。

* * *

### 五、总结

* 可调用着色器类似 GPU 上的“函数调用”，但调用代价不低。
    
* 如果你已经能使用 Miss Shader，那你也能用 Callable Shader。
    
* 但是，不要指望它比 Miss Shader 调用快多少（除了省掉实际的光线相交处理）。
    

* * *

如需我将这部分翻成代码注释或加入示例使用方式，也可以继续告诉我！